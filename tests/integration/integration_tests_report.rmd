---
title: "Ixa-epi-isolation integration tests and documentation"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  out.width = "100%",
  fig.width = 10,
  fig.align = "center"
)
```

## Preface

This report is intended to serve three purposes:

1) To generate figures and other output that, by visual inspection, serve as integration tests that demonstrate that ixa-epi-isolation is performing as expected. The primary conceptual basis for these tests is to compare output from ixa with output from ordinary differential equation models.
2) To document how to perform various modeling tasks in ixa-epi-isolation, with a focus on the specifications set in the input `.json` files.
3) To compare and contrast agent-based and ODE modeling approaches, demonstrating how ODE assumptions can be encoded in ixa.

## Background on model inputs and relationship to $\mathscr{R}_0$

Before presenting integration tests, we will review input parameters that are essential for defining the model. (Note that this is not intended to be comprehensive documentation on the input `.json` file; the input file includes variables such as `report_period` that are essential to the generation of model output but do not affect the dynamics of the model plus variables such as `proportion_asymptomatic` that must be specified for the code to run but are not essential for a minimum working transmission model.)

### `infectiousness_rate_fn`
The infectiousness rate function can be specified using either the `Constant` approach or the `EmpiricalFromFile` approach. In the former specification, every individual has the same rate and duration of infectiousness. In the following example, each simulated infected person has an intrinsic infectiousness rate of 1.5 attempted transmissions/time unit for 5.0 time units.
```
"infectiousness_rate_fn": {"Constant": {"rate": 1.5, "duration": 5.0}},
```
In the latter specification, we input a file that specifies how intrinsic infectiousness varies as a function of time since infection. We also specify a `scale` parameter that is a multiplicative adjustment to intrinsic infectiousness. For example, suppose we specify the following in the input `.json` file:
```
"infectiousness_rate_fn": {"EmpiricalFromFile": {"file": "example_rate_fn.csv",
                                                 "scale": 2.0}},
```
And further suppose that `example_rate_fn.csv` is as follows:
```
id,time,value
1,1,3
1,5,3
2,0.5,0
2,2,1.5
2,4,0
```
This example file specifies two empirical rate functions for infectiousness. In the first (`id` = 1), infectiousness occurs from 1 time unit after infection until 5 time units after infection. The `value` for the rate is 3, but note that if `"scale": 2.0` is specified in the input `.json`, then the modeled intrinsic infectiousness will be 6. In the second (`id` = 2), intrinsic infectiousness follows a "triangle" shape, starting at 0.5 time units after infection and linearly increasing to a peak 2 time units after infection, which is followed by a linear decrease until 4 time units after infection, after which there is no more infectiousness. At the peak, the rate value is 1.5, which would be scaled to 3, given the specified `scale` factor. For each infection, an empirical rate function is randomly drawn with replacement from the set of specified functions.

The information stipulated in the `infectiousness_rate_fn` is sufficient to calculate the intrinsic reproduction number $\mathscr{R}_{intrinsic}$. This value can be interpreted as the expected number of onward transmission events that would occur secondary to a typical infection if the infected person was continually in contact with one (and only one) other person, if that other person started out susceptible to infection and, upon infection, instantly reverted to being susceptible (i.e., they were able to be infected repeatedly), and if there are no interventions that might reduce infectiousness or transmission. The infectiousness rate function is best though of as the rate of infection _attempts_ rather than the rate of transmission; infection attempts may fail for reasons including a lack of susceptible contacts or by being blocked by interventions that modify transmission (e.g., mask wearing).

For the `Constant` input parameterization, where `rate`=$\beta$ and `duration`=T,
$$
\mathscr{R}_{intrinsic} = \beta T
$$

For the `EmpiricalFromFile` input parameterization, with $m$ empirical rate functions and where $\beta_i(\tau)$ is the continously interpolated `value` for the $i$-th `id` at `time` $\tau$ and $\phi$ is the `scale` parameter,
$$
\mathscr{R}_{intrinsic} = \phi\bigg(\sum_{i}\int_0^\infty\beta_i(\tau)d\tau\bigg)\big/m
$$

### `initial_incidence` and `initial_recovered`

The input parameters `initial_incidence` and `initial_recovered` specify the probability a simulated person is, respectively, infected or recovered at the start of the simulation. Note that these are probabilities, so the  number of infections at the start of the simulation is a binomial-distributed random variable. Even for `initial_incidence`>0, it is possible that any given simulation is not seeded with any infections. In the following example inputs, the expected initial prevalence of infection is 1% and there are no persons in the recovered category at the start of the simulation.
```
"initial_incidence": 0.01,
"initial_recovered": 0.0
```
These input parameters do not affect $\mathscr{R}_0$, but they do affect epidemic final size.

### `synth_population_file`
The input parameter `synth_population_file` specifies a `.csv` file with one row for each person in the simulated population. The file specifies demographic characteristics of the person (`age`) and assigns them to settings (`homeId`, `schoolId`, `workplaceId`). Everyone must be assigned a `homeId`, but `schoolID` and `workplaceId` are assigned only if relevant. Homes are by definition nested within census tracts, and the census tract is extracted from the `homeId`.

```
"synth_population_file": "tests/input/example_synth_pop.csv",
```

### `settings_properties`
The `settings_properties` input parameters define 1) the proportion of time simulated persons spend in each setting and 2) define the relationship between number of persons in a setting and the rate of infection attempts occuring in that setting. Currently, the model supports up to four settings: `Home`, `Workplace`, `School`, and `CensusTract`. For each setting, a value of `alpha` is specified along with the `ratio` in the `itinerary_specification`, as shown in the example below.

```
"settings_properties": {"Home": {"alpha": 0.0,
                                 "itinerary_specification": {"Constant": {"ratio": 0.25}}},
                        "Workplace": {"alpha": 0.0,
                                      "itinerary_specification": {"Constant": {"ratio": 0.25}}},
                        "School": {"alpha": 0.0,
                                   "itinerary_specification": {"Constant": {"ratio": 0.25}}},
                        "CensusTract": {"alpha": 0.0,
                                        "itinerary_specification": {"Constant": {"ratio": 0.25}}}},
```
The setting-specific value of `alpha` determines how the rate of infection attempts by an infectious person is affected by the number of people in a setting. Specifically, the rate of infection attempts is $\beta (n-1)^\alpha$, where $\beta$ is the intrinsic infectiousness rate, $n \geq 1$ is the number of people in the setting including the infectious person, and $0 \leq\alpha\leq 1$. To illustrate this concept, imagine two infectious persons, one of whom goes to a workplace with 10 other people and the other goes to a workplace with 20 other people. If we assume that $\alpha = 0$, then, all else equal, these two persons infect others at the same rate. But if $\alpha = 1$, then the latter person infects susceptible persons at twice the rate of the former person.

The value of `ratio` corresponds to the proportion of time that each simulated person spends in that setting. In the above example, time is equally divided across settings. (Time is divided among the settings to which a person is assigned; if neither workplace nor school is specified in the synthentic population file for a person, then that person's time would be evenly divided between "Home" and "CensusTract".) Conceptually, a person can only be in one setting at a time, but the model does not explicitly account for which units of time are spent in which settings (e.g., the model has no notion of which hours of the day a person is at school or work versus at home).

### Expected number of secondary infections
We can use the values specified in `settings_properties` along with $\mathscr{R}_{intrinsic}$ and knowledge about the population structure to estimate $\mathscr{R}_0$ under certain assumptions. Let us first consider a population with size $n$ with homogeneous mixing (e.g., all persons in the population share a single household). The expected number of secondary infections caused by an infected person, assuming all others are susceptible, is

$$
\bigg(1-\exp\bigg(-\frac{\mathscr{R}_{intrinsic}(n-1)^\alpha}{n-1}\bigg)\bigg)(n-1)
$$
$$
(1-\exp(-\mathscr{R}_{intrinsic}(n-1)^{\alpha-1}))(n-1)
$$

This expression is an application of the formula $cumulative\ incidence = 1 - \exp(-incidence\ rate \times time)$, where $\mathscr{R}_{intrinsic}(n-1)^\alpha/(n-1)$ is the _per capita_ incidence rate of infection among the susceptible people and time is implicitly scaled so that 1 unit of time corresponds to the duration of infectiousness. The cumulative incidence is the _proportion_ of susceptible people who are infected, so we multiply by $(n-1)$ to get the _count_.

The following figure shows how the expected number of secondary infections changes as a function of $\alpha$ and $n$ assuming that $\mathscr{R}_{intrinsic} = 1$. When $n=1$ the number of secondary infections is 0, because there are no susceptible persons to infect. When $n=2$, the expected number of secondary infections is $1-\exp(-\mathscr{R}_{intrinsic})$ and does not depend on $\alpha$. The maximum possible number of secondary infections is $n-1$ (i.e., the total population size minus the initially infected person); therefore, areas of the plot corresponding to more than $n-1$ secondary infections are shaded in grey.

```{r}
# load packages

library(tidyverse)
library(arrow)
```

```{r}
R_intrinsic <- 1 # nolint: object_name_linter.
alphas <- (0:5) / 5
n <- c(1:99, 10^(2:4))

secondary_infections <- sapply(alphas, function(alpha) {
  (1 - exp(-R_intrinsic * (n - 1)^(alpha - 1))) * (n - 1)
})

blue_red_palette <- colorRampPalette(c("blue", "red"))

matplot(
  x = n, y = secondary_infections, type = "l", log = "", lty = 1,
  col = blue_red_palette(length(alphas)),
  xlim = c(1, 10), ylim = c(0, 7), xaxs = "i", yaxs = "i",
  xlab = expression(italic(n) ~ "(population size)"),
  ylab = "secondary infections"
)
polygon(
  x = c(1, n, 10^4), y = c(10^4, n - 1, 10^4), col = "lightgrey",
  border = NA
)
legend("topleft",
  legend = paste("\u03B1 = ", alphas),
  col = blue_red_palette(length(alphas)), lty = 1
)
```

The figure below is very similar, but plotting both axes on the log scale and changing the axis ranges helps visualize the expected number of secondary infections in the limit as $n\to\infty$.

```{r}
matplot(
  x = n, y = secondary_infections, type = "l", log = "xy", lty = 1,
  col = blue_red_palette(length(alphas)),
  xlim = c(2, 7000), ylim = c(0.5, 7000), xaxs = "i", yaxs = "i",
  xlab = expression(italic(n) ~ "(population size)"),
  ylab = "secondary infections"
)
polygon(
  x = c(n, 10^4, 1), y = c(n - 1, 10^4, 10^4), col = "lightgrey",
  border = NA
)
legend("topleft",
  legend = paste("\u03B1 = ", alphas),
  col = blue_red_palette(length(alphas)), lty = 1
)
```

When $\alpha=0$, the expected number of secondary infections plateaus at $\mathscr{R}_{intrinsic}$, whereas when $\alpha=1$, the _proportion_ of susceptible persons that are infected by a single infectious case is a constant $1-\exp(-\mathscr{R}_{intrinsic})$. For $0<\alpha<1$, the _number_ of secondary infections goes to infinity in the limit as $n$ goes to infinity, but the _proportion_ goes to 0.

The relationship between $\mathscr{R}_{intrinsic}$ and $\mathscr{R}_{0}$ is most straightforward in the setting where $\alpha=0$ and as $n\to\infty$. Indeed, under these assumptions $\mathscr{R}_{intrinsic}=\mathscr{R}_{0}$. For $\alpha>0$, $\mathscr{R}_{0}\to\infty$ as $n\to\infty$.

Let us now consider the scenario where the population is structured into settings, but the sizes of the settings and the proportion of time in each setting is consistent across all simulated individuals (i.e., with respect to mixing patterns, all simulated individuals are equivalent). Let $\rho_j$, $\alpha_j$, and $n_j$ be the `ratio`, `alpha`, and number of people per setting, respectively, for the $j$-th setting. (Note that $n_j$ is not explicitly set in `settings_properties` but rather is implicitly set in the `synth_population_file`.) To get the expected number of secondary infections caused by a single infected individual in an otherwise wholly susceptible population, we calculate the weighted mean of the setting-specific number of secondary infections where each setting is weighted by its $\rho_j$.
$$
\sum_j\bigg(\rho_j(1-\exp(-\mathscr{R}_{intrinsic}(n_j-1)^{\alpha_j-1}))(n_j-1)\bigg)\bigg/\sum_j\rho_j
$$

## Simple SIR model
This integration test generates and analyzes simulations in ixa that are expected to align with canonical SIR compartmental model assumptions. To recreate the infectious `I` compartment of a classical SIR ODE model, we create the `tests/input/rate_fns_exp_I.csv` in R, which supplies a constant value of $\beta = 1.5$ as the infectiousness for exponentially distributed lengths of time ($\gamma=0.5$, so mean duration of infectiousness is 2 time units).

The key part of the file `tests/integration/sir/input/input_simple_SIR.json` that specifies the rate function is as follows:

```
    "infectiousness_rate_fn": {
      "EmpiricalFromFile": {
        "file": "tests/input/rate_fns_exp_I.csv",
        "scale": 1.0
      }
    }
```
```{r}
final_size_fx <- function(r0, y = 1e-10) {
  uniroot(
    f = function(z) {
      exp(-r0 * z) - (1 - z) / (1 - y)
    },
    interval = c(y, 1)
  )$root
}

simple_sir_final_size <- final_size_fx(r0 = 3, y = 0.01)
```

With the parameters used here, $\mathscr{R}_{intrinsic} = \beta/\gamma = 1.5/0.5 = 3$ and in the large-sample limit, $\mathscr{R}_{intrinsic}=\mathscr{R}_{0}=3$. For $\mathscr{R}_{0}=3$ and an initial prevalence of infection of 0.01, we expect a final size of `r simple_sir_final_size`.

We run ixa repeatedly with a small population size $N=100$ and check the output against expectations of the distribution of the number of infected individuals at the start of the simulation and expectations of the distribution of the epidemic final size.

In the following plot, the blue histogram bars represent the distribution of the number of initial infections across the simulated outbreaks, and the red dots represent the expected distribution based on a binomial distribution with probability of "success" of 0.01 and $N=100$.

```{r}
ixa_sir_df <- as.data.frame(open_dataset("sir_small/data/simulations"))

sim_pop_size <- ixa_sir_df |>
  filter(t == 0 & simulation == 0) |>
  summarize(pop_size = sum(count)) |>
  as.numeric()

ixa_sir_initial_df <- ixa_sir_df |>
  filter(InfectionStatus == "Susceptible" & t == 0) |>
  select(simulation, t, count_susceptible = count) |>
  mutate(count_infectious = sim_pop_size - count_susceptible)

inital_infect_vals <- 0:max(ixa_sir_initial_df$count_infectious)

expected_init <- dbinom(
  x = inital_infect_vals,
  size = sim_pop_size, prob = 0.01
)
expected_init_df <- data.frame(
  count_infectious = inital_infect_vals,
  expected_prop = expected_init
)

ggplot(ixa_sir_initial_df, aes(x = count_infectious)) +
  geom_histogram(aes(y = ..density..),
    binwidth = 1,
    fill = "lightblue", color = "black"
  ) +
  geom_point(
    data = expected_init_df,
    aes(x = count_infectious, y = expected_prop),
    color = "red", size = 3
  ) +
  scale_x_continuous(breaks = inital_infect_vals) +
  labs(x = "number of initial infectious persons") +
  theme_minimal()
```

```{r}
sims_1_init_infected <- ixa_sir_initial_df |>
  filter(count_infectious == 1) |>
  pull(simulation)

ixa_sir_final_df <- ixa_sir_df |>
  filter(InfectionStatus == "Recovered" & t == max(t)) |>
  select(simulation, t, final_size = count) |>
  filter(simulation %in% sims_1_init_infected)
```

Next, compare the outbreak final size distribution to the distribution we expect for $\mathscr{R}_{0}=3$ and $N=100$ (calculated using the method of Miller 2019). Here we will restrict to the `r nrow(ixa_sir_final_df)` simulations in which the initial number of infected individuals was exactly 1. The blue histogram bars represent the distribution of the epidemic final size across the simulated outbreaks, and the red dots represent the expected distribution. This plot shows that the distributions closely align.

```{r}
# get the probability of each final size

r_0 <- 3
n <- sim_pop_size

library(Rmpfr)

precision <- 128 * 4 # necessary precision depends on parameters
# this should work for N = 1000 and R0 = 3, which runs in a little over 2 mins

nxn_mat <- mpfr(matrix(nrow = n, ncol = n), precision)
m_vec <- mpfr(seq_len(n), precision)
r_0 <- mpfr(r_0, precision)
c_1_m <- 1 + r_0 * (1 - (m_vec - 1) / (n - 1))

nxn_mat[, 1] <- c_1_m

for (k in 2:n) {
  nxn_mat[, k] <- (m_vec - k + 1) / (n - k + 1) * c_1_m * nxn_mat[, k - 1]
}

l <- nxn_mat
b <- mpfr(matrix(data = 1, nrow = n, ncol = 1), precision)

x <- mpfr(rep(0, n), precision)

# the following loop is equivalent to the function forwardsolve
# forwardsolve works with smaller populations, but runs into numerical issues
for (i in 1:n) {
  sum_lx <- mpfr(0, precision)
  if (i > 1) {
    sum_lx <- sum(l[i, 1:(i - 1)] * x[1:(i - 1)])
  }
  x[i] <- (b[i] - sum_lx) / l[i, i]
}

expected_final_df <- data.frame(
  final_size = 1:n,
  expected_prop = as.numeric(x)
)

# plot simulated and expected results

ggplot(ixa_sir_final_df, aes(x = final_size)) +
  geom_histogram(aes(y = ..density..),
    binwidth = 1,
    fill = "lightblue", color = "black"
  ) +
  geom_point(
    data = expected_final_df,
    aes(x = final_size, y = expected_prop),
    color = "red", size = 1
  ) +
  labs(x = "epidemic final size") +
  theme_minimal()
```

While the final size of the outbreak is an important property, it is also necessary to test whether the time-course of simulated outbreaks aligns with what we expect from the corresponding deterministic ODE model. We will restrict to the simulated outbreak trajectories with a single initial infected case that "took off" and caused an epidemic. (We somewhat arbitrarily define "epidemics" as those simulations with a final size at least half the expected final size.) The dashed colored lines represent the mean of the simulated epidemics, while the solid colored lines show the deterministic ODE solution. The light grey dashed horizontal line is the expected outbreak final size. The simulated dynamics mirror the ODE dynamics closely, although the mean simulated peak prevalence of infection is lower than expected from the ODE model.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
epidemic_sims <- ixa_sir_final_df |>
  filter(final_size > (sim_pop_size * simple_sir_final_size / 2)) |>
  pull(simulation)

ixa_sir_epidemic_df <- ixa_sir_df |> filter(simulation %in% epidemic_sims)

ixa_sir_epidemic_summary <- ixa_sir_epidemic_df |>
  group_by(t, InfectionStatus) |>
  summarize(
    mean_count = mean(count),
    error = qnorm(p = 0.975) * sd(count) / sqrt(n()),
    lower_95_ci = mean_count - error,
    upper_95_ci = mean_count + error
  )

ode_results_sir <- read.csv("../input/ode_results_SIR.csv")
ode_results_sir$InfectionStatus <- factor(ode_results_sir$InfectionStatus,
  levels = c("Susceptible", "Infectious", "Recovered")
)

ixa_sir_epidemic_df |>
  ggplot() +
  xlab("Time") +
  ylab("Number of people (prevalence)") +
  theme_minimal() +
  geom_line(
    data = ode_results_sir,
    aes(x = t, y = count, color = InfectionStatus)
  ) +
  geom_line(
    data = ixa_sir_epidemic_summary,
    aes(x = t, y = mean_count, color = InfectionStatus), lty = 2
  ) +
  geom_hline(
    yintercept = simple_sir_final_size * sim_pop_size,
    col = "grey", lty = 5, lwd = 0.5
  ) +
  scale_color_manual(values = c(
    "Susceptible" = "blue",
    "Infectious" = "red", "Recovered" = "green"
  ))
```

## Simple SEIR model
This integration test compares output from ixa with output from a simple SEIR ODE model. The approach here is very similar as in the SIR example; the only difference is that empirical infectiousness rate function is constructed so there is an exponentially distributed period from when infection occurs to when infectiousness begins. During that period the infectiousness rate is set to zero.

The file `tests/integration/seir/input/input_simple_SEIR.json` was modfied as follows to specify a different rate function.

```
    "infectiousness_rate_fn": {
      "EmpiricalFromFile": {
        "file": "tests/input/rate_fns_exp_E_exp_I.csv",
        "scale": 1.0
      }
    }
```
Identical to the simple SIR case above, $\mathscr{R}_{intrinsic} = \beta/\gamma = 1.5/0.5 = 3$ and in the large sample limit, $\mathscr{R}_{intrinsic}=\mathscr{R}_{0}=3$.

The following figure shows simulated outbreak trajectories (faint dashed lines) and the ODE results (thick solid lines). The "susceptible" and "recovered" ODE results broadly mirror the corresponding results from ixa simulations. But the dashed red lines representing "infectious" persons in ixa have a much higher peak that the solid red line for "infectious" from the ODE model. This is not an error, but rather illustrates an important conceptual difference between the modeling approaches: In ixa, there is no explicit "exposed" category. Rather, the "exposed" category is implicitly modeled through the infectiousness rate functions. The "infectious" category in ixa is effectively the sum of the "exposed" and "infectious" categories in the ODE model. Comparing the SIR and SEIR output, we see, as expected, that the final epidemic size is unchanged but that the time course of the epidemic is delayed (e.g., in the SIR model less than half the population is susceptible 5 time units after the start of the epidemic, but in the SEIR model, it takes about twice as long to reach the same state).

```{r, echo = FALSE}
ixa_seir_df <- as.data.frame(open_dataset("seir/data/simulations"))

ode_results_seir <- read.csv("../input/ode_results_SEIR.csv")

ode_results_seir$InfectionStatus <- factor(ode_results_seir$InfectionStatus,
  levels = c("Susceptible", "Exposed", "Infectious", "Recovered")
)

ixa_seir_df |>
  ggplot() +
  geom_line(
    aes(
      x = t, y = count,
      group = interaction(simulation, InfectionStatus), color = InfectionStatus
    ),
    alpha = 0.1, lty = 2
  ) +
  xlab("Time") +
  ylab("Number of people (prevalence)") +
  theme_minimal() +
  geom_line(
    data = ode_results_seir,
    aes(x = t, y = count, color = InfectionStatus), lwd = 2
  ) +
  scale_color_manual(values = c(
    "Susceptible" = "blue", "Exposed" = "purple",
    "Infectious" = "red", "Recovered" = "green"
  ))
```

### SIR model with one person per household

To test the implementation of settings and how settings affect the reproduction number, we consider a synthetic population consisting of a single census tract with 100 residents and with one person per household. Upon this population we implement the SIR model with $\mathscr{R}_{intrinsic}=3$. We assume that people spend one quarter of their time at home and the remainder of their time in the census tract at large (no schools or workplaces are specified). We continue to assume that $\alpha = 0$. Using the expression from above, we find that the expected number of secondary infections is

$$
\frac{\begin{split}\rho_{Home}(1-\exp(-\mathscr{R}_{intrinsic}(n_{Home}-1)^{\alpha_{Home}-1}))(n_{Home}-1) + \\\rho_{CensusTract}(1-\exp(-\mathscr{R}_{intrinsic}(n_{CensusTract}-1)^{\alpha_{CensusTract}-1}))(n_{CensusTract}-1)\end{split}}{\rho_{Home} + \rho_{CensusTract}}
$$
$$
\frac{0.25(1-\exp(-3(1-1)^{0-1}))(1-1) + 0.75(1-\exp(-3(100-1)^{0-1}))(100-1)}{0.25 + 0.75}
$$
$$
0.75(1-\exp(-3/99))(99)
$$
$$
\approx2.2163
$$

Intuitively, we would expect that because each person spends one fourth of their time alone at home, this is equivalent to reducing $\beta$ by one fourth and so $\mathscr{R}_0$ in this example should be $3/4\times 3=2.25$. Conceptually, the difference between this $\mathscr{R_0}$ value and the expected number of secondary infections ($\approx2.2163$) lies in the finiteness of the population. When $\mathscr{R}_0=2.25$ and in the limit where the initial proportion infected goes to zero, the expected final size proportion is `r final_size_fx(r0 = 3*3/4, y = 0.000000000001)`.

```
"synth_population_file": "tests/input/pop_unique_hh.csv",
"settings_properties": {"Home": {"alpha": 0.0,
                                 "itinerary_specification": {"Constant": {"ratio": 0.25}}},
                        "CensusTract": {"alpha": 0.0,
                                        "itinerary_specification": {"Constant": {"ratio": 0.75}}}},
```

In the following figure, the dashed colored lines represent the mean of the simulated epidemics that "took off" and had 1 initial infected person, while the solid colored lines show the deterministic ODE solution for $\mathscr{R}_0 = 2.25$. The light grey dashed horizontal line is the expected outbreak final size. The simulated dynamics mirror the ODE dynamics closely, although not exactly.

```{r}
sir_unique_hh_final_size <- final_size_fx(r0 = 3 * 3 / 4, y = 0.000000000001)

ixa_sir_unique_hh_df <- as.data.frame(
  open_dataset("sir_unique_hh/data/simulations")
)

sim_pop_size <- ixa_sir_unique_hh_df |>
  filter(t == 0 & simulation == 0) |>
  summarize(pop_size = sum(count)) |>
  as.numeric()

ixa_sir_unique_hh_initial_df <- ixa_sir_unique_hh_df |>
  filter(InfectionStatus == "Susceptible" & t == 0) |>
  select(simulation, t, count_susceptible = count) |>
  mutate(count_infectious = sim_pop_size - count_susceptible)

sims_1_init_infected <- ixa_sir_unique_hh_initial_df |>
  filter(count_infectious == 1) |>
  pull(simulation)

ixa_sir_unique_hh_final_df <- ixa_sir_unique_hh_df |>
  filter(InfectionStatus == "Recovered" & t == max(t)) |>
  select(simulation, t, final_size = count) |>
  filter(simulation %in% sims_1_init_infected)

epidemic_sims <- ixa_sir_unique_hh_final_df |>
  filter(final_size > (sim_pop_size * sir_unique_hh_final_size / 2)) |>
  pull(simulation)

ixa_sir_unique_hh_epidemic_df <- ixa_sir_unique_hh_df |>
  filter(simulation %in% epidemic_sims)

ixa_sir_uni_hh_epi_summary <- ixa_sir_unique_hh_epidemic_df |>
  group_by(t, InfectionStatus) |>
  summarize(
    mean_count = mean(count),
    error = qnorm(p = 0.975) * sd(count) / sqrt(n()),
    lower_95_ci = mean_count - error,
    upper_95_ci = mean_count + error
  )

ode_results_sir <- read.csv("../input/ode_results_SIR_unique_hh.csv")
ode_results_sir$InfectionStatus <- factor(ode_results_sir$InfectionStatus,
  levels = c("Susceptible", "Infectious", "Recovered")
)

ixa_sir_unique_hh_epidemic_df |>
  ggplot() +
  xlab("Time") +
  ylab("Number of people (prevalence)") +
  theme_minimal() +
  geom_line(
    data = ode_results_sir,
    aes(x = t, y = count, color = InfectionStatus)
  ) +
  geom_line(
    data = ixa_sir_uni_hh_epi_summary,
    aes(x = t, y = mean_count, color = InfectionStatus), lty = 2
  ) +
  geom_hline(
    yintercept = sir_unique_hh_final_size * sim_pop_size,
    col = "grey", lty = 5, lwd = 0.5
  ) +
  scale_color_manual(values = c(
    "Susceptible" = "blue",
    "Infectious" = "red", "Recovered" = "green"
  ))
```
